## 1️ 문제를 “사람 말로” 다시 정의하기

> “트리 안에서 위에서 아래로 내려가는 어떤 경로든,
> 합이 targetSum이 되는 모든 경우의 수를 찾아라.”

여기서 “경로”는

* 루트에서 시작하지 않아도 되고,
* 리프에서 끝나지 않아도 되고,
* 단, **부모 → 자식 방향**으로만 이동한다.

즉,
모든 노드를 시작점으로 두고
그 노드에서 **밑으로 쭉 내려가며 합을 누적**해보면 된다.

---

## 2️ DFS로 접근해야 하는 이유

트리는 “분기 구조”라서
**각 노드마다 왼쪽과 오른쪽으로 재귀 탐색(DFS)** 하는 게 자연스러워.

즉, DFS는

> “이 노드부터 밑으로 어떤 합들이 만들어질 수 있는가?”
> 를 알아내는 데 최적화되어 있다.

---

## 3️ 문제를 두 단계로 쪼개기

트리 전체를 한 번에 보지 말고, 이렇게 생각해봐.

### (1) pathSum(root, targetSum)

→ “모든 노드를 시작점으로 해보자.”

즉,
현재 노드(root)를 시작점으로 하는 경우 +
왼쪽 서브트리에서 시작하는 경우 +
오른쪽 서브트리에서 시작하는 경우를 모두 합친다.

```java
pathSum(root) = countPaths(root) + pathSum(root.left) + pathSum(root.right)
```

---

### (2) countPaths(node, target)

→ “현재 노드에서 시작해서, 밑으로만 내려가며 합이 target인 경로 수를 세자.”

즉,
현재 노드의 값을 target에서 빼고,
왼쪽과 오른쪽으로 계속 내려가며 재귀적으로 세면 된다.

```java
countPaths(node, target):
    if node == null: return 0
    cnt = 0
    if (node.val == target) cnt++
    cnt += countPaths(node.left, target - node.val)
    cnt += countPaths(node.right, target - node.val)
    return cnt
```

---

## 4️ DFS로 생각하는 흐름 시각화

예를 들어 트리가 이렇게 생겼다고 하자:

```
     10
    /  \
   5   -3
  / \    \
 3   2    11
```

targetSum = 8

---

### (1) 루트(10)에서 시작

* 현재 값 10 → target 8과 다름 → 0
* 왼쪽 자식 5로 내려가며 target 8 - 10 = -2
* 오른쪽 자식 -3으로 내려가며 target 8 - 10 = -2

이 과정이 **countPaths(10, 8)**

---

### (2) 왼쪽 서브트리(5)에서 시작

* 현재 값 5 → target 8 → 아직 부족함 (target-5=3)
* 자식(3, 2)을 탐색

  * 3에서 3==3 → 1개 경로 발견 (5→3)
  * 2에서 3-2=1 → 계속 탐색
* countPaths(5,8)=2

---

이런 식으로 모든 노드가 "출발점"이 되어 DFS를 돌며
각각의 밑방향 경로를 세는 구조야.

---

## 5️ DFS를 직접 따라 그려보기

DFS는 기본적으로 **“스택에 남는 흐름”**이야.
이걸 머릿속에 그리면 훨씬 명확해진다.

예를 들어:

```
DFS(10,8)
 ├── DFS(5, -2)
 │     ├── DFS(3, -7)
 │     └── DFS(2, -7)
 └── DFS(-3, -2)
        └── DFS(11, -5)
```

이렇게 **트리 전체를 한 번 다 순회하면서**,
각 노드마다 “내려가는 합”을 세면 된다.

---

## 6️ DFS 사고 순서 정리

| 단계 | 생각의 흐름                                        | 코드에서 하는 일                                  |
| -- | --------------------------------------------- | ------------------------------------------ |
| 1  | 현재 노드가 비었으면 멈춘다                               | `if(node == null) return 0;`               |
| 2  | 현재 노드가 target과 같으면 카운트 +1                     | `if(node.val == target) cnt++;`            |
| 3  | target을 줄이고 자식으로 내려간다                         | `countPaths(node.left, target - node.val)` |
| 4  | 모든 자식 탐색이 끝나면 count 반환                        | `return cnt;`                              |
| 5  | 이 과정을 모든 노드(root, root.left, root.right)에서 반복 | `pathSum()` 호출                             |

---

## 7️ 이렇게 연습해보면 완전히 이해된다

1. **손으로 작은 트리 직접 그리기**

   * 예: `[1,2,3]`, target=3
   * 가능한 모든 경로를 사람이 세어보고,
     `DFS`가 어떤 순서로 방문하는지 종이에 써보기.

2. **`countPaths()`만 단독 실행해보기**

   * “한 노드 기준”에서 경로 합을 세는 코드만 따로 돌려보면
     DFS의 의미가 완전히 감이 잡힌다.

3. **출력 로그 찍기**

   ```java
   System.out.println("node=" + node.val + " target=" + target);
   ```

   이렇게 찍어보면 “DFS가 어떤 순서로 순회하는지” 시각적으로 알 수 있다.

---

## 8️ 정리: DFS 풀이 감 잡는 핵심

| 핵심 포인트      | 설명                                                      |
| ----------- | ------------------------------------------------------- |
|  목표       | “모든 노드에서 밑으로 내려가는 모든 경로의 합”                             |
|  사고법      | “현재 노드에서 시작했을 때 target을 채울 수 있을까?”                      |
|  재귀 구조    | `countPaths()`로 하위 탐색 + `pathSum()`으로 시작점 변경            |
|  실수 포인트   | (1) 누적합 vs 남은 target 혼동 (2) null 처리 빠짐 (3) int overflow |
|  익숙해지는 방법 | 경로를 직접 써보고, 호출 흐름을 따라가보기                                |

---
